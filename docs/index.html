<!DOCTYPE html>
<html>
<head>
  <title>Godot Save/Load Game State</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-gdscript.min.js"></script>
  <style>
    body {
      text-align: center;
      overflow: auto;
      background-color: #286b40;
      font-family: Helvetica;
      font-size: 16px;
      line-height: 25px;
    }

    .scroll-region {
      display: inline-block;
      width: 70%;
      max-width: 1000px;
      padding: 50px 20px 100px 20px;
      text-align: left;
      background-color: #a3cfb3;
    }

    pre[class*="language-"]{
    }

    pre[class*="language-"],
    code[class*="language-"]{
        background-color: #071f0f;
        text-shadow: none;
        color: #a3cfb3;
        margin: 0;
    }

    .token.operator {
        background: none;
    }

    .with-indent {
        text-indent: 5%;
    }

    .center-img {
        text-align: center;
    }

    .underline-godot {
        font-weight: bold;
        color: #440044;
    }

    hr {
        height: 3px;
        border: 0;
        background-color: #286b40;
    }

    h1 {
      font-size: 30px;
      padding-top: 70px;
    }

    h2 {
      font-size: 22px;
    }
  </style>
</head>
<body>
  <div class="scroll-region">
    <h1 style="font-size:55px;text-align:center;">Godot Save/Load Game State</h1>

    <h1>Index</h1>
    <a href="#explained"><h2>Explanation</h2></a>
    <a href="#tutorial"><h2>Tutorial</h2></a>
    <a href="#methods"><h2>Method descriptions</h2></a>
    <a href="#format"><h2>File format</h2></a>
    <hr>

    <h1 id="explained">Explanation</h1>
    <p class="with-indent">Any save game system works by taking all of the information stored by the game objects, packs them in such a way that they can be saved to the disk and afterwards it can be retrieved from the disk and repopulate that information back into the game objects or levels.</p>
    <p class="with-indent">This system is designed in such a way so any kind of game would be able to use it. This is done by enforcing a small amount of constraints on how the levels and the objects should be stored on the disk.</p>
    <p class="with-indent">The plugin introduces a new Godot game object called a Savestate, which is also tied to a filename and is able to store the game state at any given point in time. You can add variables to this save state, or you can add levels. If you have multiple levels in your game, it can also save separate entries for each of the levels. The constraint done on the levels is that all levels should contain collections, and the collections are the actual Node that contains the game objects. For example a level could have a collection of bullets and the collection of enemies and maybe the save game wouldn't save the bullets, but it is important that all game objects are children to one of these Node object.  The node object we are talking about is either a Node, Spatial or Node2d,  depending on the use case and how the game objects are being used, but it's very important to be grouped as such.</p>
    <p class="with-indent">Marking an object to be saved to the disk is done by simply declaring which variables need to be saved. This is done by creating a <u class="underline-godot">serializable</u> variable and add inside of it the names of the variables that need to be saved into the save file. In the same manner the levels will have a <u class="underline-godot">serializable_collections</u> is variable that needs to be populated with the names of the collections.</p>
    <p class="with-indent">After the Savestate object has been informed on which variables and objects needs to be saved, by just calling a simple function, detailed below, that state is saved to the disk and later on it can be loaded, all that information ready to be repopulated in the original objects.</p>
    <p class="with-indent">Because the system is also capable of handling variables which are not tied to levels or objects,  means that the system can also be used to save the configuration of the game itself. As previously mentioned the only thing that needs to be done is to mark the relevant variables and pack them to the Savestate.</p>
    <hr>

    <h1 id="tutorial">Tutorial</h1>
    <p class="with-indent">This tutorial is not supposed to explain the more complicated cases where the game would have multiple maps, open world or other special settings. The tutorial is destined to explain the most basic use case, which means saving variables and saving object states.</p>
    <p class="with-indent">First of all we will need to have a scene for the level itself, that has buttons meant to be clicked in order to load & save. This level scene will contain one collection (which is a Node2D in this example) that will contain the objects that we want to save.</p>
    <p class="center-img"><img src="level0.png"></img></p>
    <p class="with-indent">The <u class="underline-godot">buttons</u> node contains buttons that when clicked will trigger the load & save functions. Node name <u class="underline-godot">objects</u> contains the objects that will get serialized and saved in the file. Any changes to these will be saved.</p>
    <p class="with-indent">Node called <u class="underline-godot">Savestate</u> is the one which is responsible for loading and saving the data. For this to work, we first need to input the filename of the save first by completing the field in the Inspector.<br>(This can also be done programatically by changing the variable <u class="underline-godot">save_filename</u> of the Savestate node)</p>

    <p class="center-img"><img src="savestate.png"></img></p>
    <p class="with-indent">Here is the code that will handle the events from the load & save buttons:</p>
    <pre><code class="language-gdscript">extends Node2D

# declare that all game objects from the collection called objects should be saved
const serializable_collections = [
	"objects"
]

# when the load button is pressed
func _on_buttons_load_pressed():
    # first load the state of the game from the disk
	$Savestate.load_game_state()
    # unpack that state loaded into this scene
    # this will remove all the objects from the node objects
    # and will populate it with the objects as written in the file on disk
	$Savestate.unpack_game_state(self)

func _on_buttons_save_pressed():
    # first you need to load the state on the disk
    # this is needed because there might be information about other game states
	$Savestate.load_game_state()
    # this appends the current level node's data to the game state
	$Savestate.pack_game_state(self)
    # finally it is saved to the disk
	$Savestate.save_game_state()</code></pre>

    <hr>

    <h1 id="methods">Method descriptions</h1>
    <hr>

    <h2>visited_level(level)</h2>
    <p>Returns a boolean indicating whether a level has been visited.</p>
    <p><strong>Input:</strong> level - the level object to check</p>
    <p><strong>Output:</strong> Boolean</p>
    <hr>

    <h2>clear_level_history(level_filename)</h2>
    <p>Removes the given level history from the current game state.</p>
    <p><strong>Input:</strong> String - the level filename</p>
    <hr>

    <h2>save_exists()</h2>
    <p>Returns a boolean indicating whether a save file exists.</p>
    <p><strong>Output:</strong> A boolean indicating whether the save file exists</p>
    <hr>

    <h2>pack_game_state(level)</h2>
    <p>Adds the given level to the current game state. It does this by serializing the level, adding all the variables registered in <u class="underline-godot">serializable</u> and/or collections registered in <u class="underline-godot">serializable_collections</u>.</p>
    <p><strong>Input:</strong> level - the level object to add to the game state</p>
    <hr>

    <h2>unpack_game_state(level)</h2>
    <p>Restores the state of the given level from the current game state. The variables in this object will be overwritten and collections will be repopulated.</p>
    <p><strong>Input:</strong> level - the level object to restore the state for</p>
    <hr>

    <h2>set_game_variables(node)</h2>
    <p>Adds variables of the given node to the current game state.</p>
    <p><strong>Input:</strong> node - the node whose variables to save to the game state</p>
    <hr>

    <h2>get_game_variables(node)</h2>
    <p>Restores the variables of the given node from the current game state.</p>
    <p><strong>Input:</strong> node - the node whose variables to restore from the game state</p>
    <hr>

    <h2>load_game_state(game_version = "default")</h2>
    <p>Loads the game state from a save file. This will overwrite the current game state, this means that any packing done before calling this function will be lost, packing should be done after a load to append new map data to a save. Optionally a version of the game can be provided, by default the game version is "default". This is useful if the object format has changed for the game and not compatible with older versions</p>
    <p><strong>Input:</strong> game_version - the version of the game state to load (optional, default value is "default")</p>
    <hr>

    <h2>save_game_state(game_version = "default")</h2>
    <p>Saves the current game state to a save file.</p>
    <p><strong>Input:</strong> game_version - the version of the game state to save (optional, default value is "default")</p>

    <h1 id="format">File format</h1>
    <pre><code id="savestate-schema" class="language-json">{}</code></pre>
    <script>
        var schema_holder = document.getElementById("savestate-schema");
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.onreadystatechange = function(){
            if(xmlHttp.readyState == 4 && xmlHttp.status == 200){
                schema_holder.innerHTML = xmlHttp.responseText;
                Prism.highlightAll();
            }
        }
        xmlHttp.open("GET", "schema.json", false);
        xmlHttp.send(null);
    </script>
    <p class="with-indent">The system saves and loads game state data in a specific format defined in a JSON-like file.The game state data is stored in a dictionary-like structure with the top level key being a version name string "$version_name". Each version name points to a dictionary containing two keys, "variables" and "maps".The "variables" key holds information about game-wide variables and their values.The "maps" key is also a dictionary that holds information about saved map state data. Each key within the "maps" dictionary is a string representing the file name of the map in the format of "$map_file_name.tscn". The value of each key is another dictionary that holds information about the saved state of the map.This map dictionary has two keys, "collections" and "objects". The "collections" key holds information about the state of various object collections in the map. The "objects" key holds information about individual objects within the map.Each object in the "collections" or "objects" keys is represented by a dictionary with several keys. The "type" key is a string indicating the type of object being saved. The "name" key holds the name of the object as a string. The "filename" key holds the file name of the object as a string. The "transform" keys hold information about the object's position, scale, and rotation. The "variables" key holds a dictionary of object-specific variables and their values.Each variable within the "variables" key of an object is also represented by a dictionary with a "type" key indicating the type of the variable and other keys holding the value of the variable. The supported types of variables include a normal numeric or boolean value, "object", "vector2", "vector3", "color", "transform", "object" and "array". The array variable can contain any of the other types recursively.</p>
    <hr>
  </div>
</body>
</html>
